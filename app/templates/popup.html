<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Facilitator Timer</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Lato&family=Playfair+Display&family=Oswald&family=Source+Sans+Pro&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      height: 100vh;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      color: #333;
      overflow: hidden;
    }

    .container {
      display: flex;
      width: 100%;
      height: 100%;
      position: relative;
      backdrop-filter: blur(10px);
    }

    .dot-column {
      position: absolute;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 10;
    }

    .left-dots {
      bottom: 40px;
      left: 20px;
      align-items: flex-start;
    }

    .right-dots {
      bottom: 40px;
      right: 20px;
      align-items: flex-end;
    }

    .dot {
      border-radius: 50%;
      width: 16px;
      height: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: all 0.3s ease;
    }

    .dot:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    }

    .red {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .green {
      background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .center {
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 24px;
      padding-top: 40px;
      z-index: 5;
    }

    .timer-display {
      font-size: clamp(2rem, 30vw, 30rem);
      margin: 0;
      line-height: 1;
      font-weight: 700;
      text-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(10px);
      padding: 20px;
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .timer-display.gradient-text {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.7) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .buttons {
      display: grid;
      grid-template-columns: 60px auto 60px 60px;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-top: 20px;
      width: 100%;
      max-width: 500px;
    }

    .buttons.single {
      grid-template-columns: auto;
    }

    :root {
      --btn-primary: #333;
      --btn-secondary: #666;
      --text-light: rgba(255, 255, 255, 0.9);
      --text-dark: rgba(0, 0, 0, 0.9);
      --text-contrast: rgba(255, 255, 255, 0.9);
      --button-bg-light: rgba(255, 255, 255, 0.1);
      --button-bg-dark: rgba(0, 0, 0, 0.1);
      --button-bg-contrast: rgba(255, 255, 255, 0.1);
    }

    /* Dynamic contrast classes */
    .contrast-light {
      color: var(--text-dark) !important;
    }

    .contrast-dark {
      color: var(--text-light) !important;
    }

    .button-contrast-light {
      background: var(--button-bg-dark) !important;
      color: var(--text-dark) !important;
      border-color: rgba(0, 0, 0, 0.3) !important;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2) !important;
    }

    .button-contrast-dark {
      background: var(--button-bg-light) !important;
      color: var(--text-light) !important;
      border-color: rgba(255, 255, 255, 0.3) !important;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1) !important;
    }

    .timer-contrast-light {
      color: var(--text-dark) !important;
      text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3) !important;
    }

    .timer-contrast-dark {
      color: var(--text-light) !important;
      text-shadow: 0 4px 20px rgba(255, 255, 255, 0.3) !important;
    }

    #config-button.icon-only {
      border: none;
      background: none;
      padding: 0;
      width: auto;
      height: auto;
      color: rgba(255, 255, 255, 0.95);
    }

    #config-button.icon-only svg {
      width: 2em;
      height: 2em;
      color: inherit;
      stroke: currentColor;
    }

    .buttons button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-family: inherit;
      font-size: 1.1rem;
      font-weight: 600;
      padding: 12px 24px;
      border-radius: 50px;
      border: 2px solid var(--button-bg-contrast, rgba(255, 255, 255, 0.3));
      background: var(--button-bg-contrast, rgba(255, 255, 255, 0.1));
      backdrop-filter: blur(10px);
      cursor: pointer;
      transition: all 0.3s ease;
      color: var(--text-contrast, rgba(255, 255, 255, 0.9));
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    }

    .buttons button:hover {
      background: var(--button-bg-contrast, rgba(255, 255, 255, 0.2));
      opacity: 0.8;
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    }

    .buttons button.primary-idle {
      background: rgba(255, 255, 255, 0.15);
      color: rgba(255, 255, 255, 0.95);
    }

    .buttons button.primary-active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-color: rgba(255, 255, 255, 0.5);
    }

    .buttons button.secondary {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
    }

    .buttons .icon,
    .buttons svg {
      width: 1.2em;
      height: 1.2em;
      line-height: 1;
    }

    .buttons button.round {
      width: 60px;
      height: 60px;
      padding: 0;
      justify-content: center;
      border-radius: 50%;
      flex-shrink: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .buttons button.round .icon {
      margin: 0;
    }

    .round {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 60px;
      height: 60px;
      padding: 0;
      border-radius: 50%;
      border: 2px solid var(--button-bg-contrast, rgba(255, 255, 255, 0.3));
      font-size: 1.1rem;
      font-weight: 600;
      background: var(--button-bg-contrast, rgba(255, 255, 255, 0.1));
      backdrop-filter: blur(10px);
      cursor: pointer;
      transition: all 0.3s ease;
      color: var(--text-contrast, rgba(255, 255, 255, 0.9));
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    }

    .round:hover {
      background: var(--button-bg-contrast, rgba(255, 255, 255, 0.2));
      opacity: 0.8;
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    }

    .round svg {
      width: 1.2em;
      height: 1.2em;
    }

    .qr-section {
      margin-top: 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      padding: 20px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      color: var(--text-contrast, rgba(255,255,255,0.9));
    }
    .qr-section.contrast-light {
      color: var(--text-dark) !important;
    }
    .qr-section.contrast-dark {
      color: var(--text-light) !important;
    }
    .qr-section img {
      width: 140px;
      height: 140px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease;
    }

    .qr-section img:hover {
      transform: scale(1.05);
    }

    .qr-label {
      font-size: 0.85rem;
      color: inherit !important;
      opacity: 0.8;
      text-align: center;
      text-shadow: 0 2px 8px rgba(0,0,0,0.18);
    }

    #session-indicator {
      font-size: 0.9rem;
      color: inherit !important;
      text-decoration: underline;
      cursor: pointer;
      transition: color 0.3s ease;
      font-weight: 500;
      text-shadow: 0 2px 8px rgba(0,0,0,0.18);
    }

    #session-indicator:hover {
      color: white !important;
    }

    @keyframes flash {
      0%, 100% { 
        opacity: 1;
        text-shadow: 0 4px 20px rgba(255, 0, 0, 0.3);
      }
      50% { 
        opacity: 0.8;
        text-shadow: 0 4px 20px rgba(255, 0, 0, 0.6);
      }
    }

    .flashing-red {
      color: #ff6b6b !important;
      text-shadow: 0 4px 20px rgba(255, 107, 107, 0.5);
      animation: flash 1s infinite;
    }

    .hidden {
      display: none !important;
    }

    @media (min-width: 651px) {
      #config-button {
        position: fixed;
        left: 80px;
        bottom: 20px;
        margin: 0;
      }
    }

    @media (max-width: 650px) {
      #config-button {
        display: none !important;
      }
    }

    @media (max-width: 600px) {
      .container > .dot-column,
      .buttons,
      .qr-section {
        display: none !important;
      }

      .center {
        padding-top: 20px;
        justify-content: center;
        align-items: center;
      }

      .timer-display {
        font-size: clamp(3rem, 30vw, 12rem);
      }
    }

    @media (max-width: 600px) and (min-height: 300px) {
      .container > .dot-column {
        display: flex !important;
      }

      .buttons,
      .qr-section {
        display: none !important;
      }

      .center {
        padding-top: 20px;
        justify-content: center;
        align-items: center;
      }

      .timer-display {
        font-size: clamp(3rem, 30vw, 12rem);
      }
    }
    .dot-img {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.3);
      transition: all 0.3s ease;
      object-fit: cover;
      display: block;
      background: none;
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    }

    .dot-img:hover {
      transform: scale(1.1);
      filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
      border-color: rgba(255, 255, 255, 0.5);
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="left-dots" class="dot-column left-dots"></div>

    <div class="center">
      <h1 id="timer-display" class="timer-display">00:00</h1>
      <div class="buttons">
        <button id="options-button"
                class="secondary round hidden"
                title="Open Settings">
          <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em"
               viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round"
               class="icon icon-tabler icon-tabler-pencil">
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
            <path d="M13.5 6.5l4 4" />
          </svg>
        </button>

        <button id="toggle-button"
                class="primary-idle">
          <!-- Play icon -->
          <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em"
               viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round"
               class="icon icon-tabler icon-tabler-player-play">
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M7 4v16l13 -8z" />
          </svg>
          Start
        </button>

        <button id="reset-button"
                class="secondary round hidden"
                title="Reset App">
          <!-- Rotate‑clockwise icon -->
          <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em"
               viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round"
               class="icon icon-tabler icon-tabler-rotate-clockwise">
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M4.05 11a8 8 0 1 1 .5 4m-.5 5v-5h5" />
          </svg>
        </button>

        <button id="chart-button"
                class="secondary round hidden"
                title="Statistics">
          <!-- Chart column icon -->
          <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em"
               viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round"
               class="icon icon-tabler icons-tabler-outline icon-tabler-chart-column">
            <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
            <path d="M4 20h3" />
            <path d="M17 20h3" />
            <path d="M10.5 20h3" />
            <path d="M4 16h3" />
            <path d="M17 16h3" />
            <path d="M10.5 16h3" />
            <path d="M4 12h3" />
            <path d="M17 12h3" />
            <path d="M10.5 12h3" />
            <path d="M4 8h3" />
            <path d="M17 8h3" />
            <path d="M4 4h3" />
          </svg>
        </button>
      </div>

      <!-- Edit-config button removed - now available in Settings window -->

              <div class="qr-section">
          <img src="" alt="QR Code" onclick="openQrPopup()" style="cursor: pointer;">

        <div style="font-size: 0.85rem; display: flex; gap: 12px; align-items: center;">
          <span id="session-indicator"
                onclick="openSettings()"
                style="text-decoration: underline; cursor: pointer;">
            No session ID currently defined
          </span>
        </div>

        <div class="qr-label">(c) Patrick Zakher - Facilitator Timer v5.1</div>
      </div>
    </div>

    <div id="right-dots" class="dot-column right-dots"></div>
  </div>

  <script>
    // ─── Detect ?session=XYZ on first load and store ───
    (function initSessionFromURL() {
      const urlSess = new URLSearchParams(window.location.search).get("session");
      if (urlSess) {
        sessionStorage.setItem("session", urlSess);
      }
    })();

    // ─── Single source of truth: current session state ───
    let sessionState = {
      minutes: 0,
      seconds: 0,
      red_teams: 0,
      green_teams: 0,
      dot_size: "S",
      background_color: "#d0f0ff",
      font_color: "#000000",
      font_family: "Courier New",
      background_image: null,
      custom_font_color_set: false,
      dot_style: "datadog_bits",
      contrast_mode: "auto"
    };

    // ─── UI state ───
    let totalSeconds = 0;
    let intervalId = null;
    let lastSeenCount = 0;
    let wasTimerRunning = false; // Track if timer was running when reset was clicked
    let initialScanCountLoaded = false;

    // ─── DOM elements ───
    const optionsBtn = document.getElementById("options-button");
    const toggleBtn = document.getElementById("toggle-button");
    const resetBtn = document.getElementById("reset-button");
    const chartBtn = document.getElementById("chart-button");
    // configBtn removed - edit-config functionality moved to Settings window
    const timerDisplay = document.getElementById("timer-display");
    const buttonsContainer = document.querySelector(".buttons");

    // ─── Helper functions ───
    function getCurrentSession() {
      const stored = sessionStorage.getItem("session");
      if (stored && stored !== "default") {
        return stored;
      }
      const text = document.getElementById("session-indicator").textContent;
      if (text.startsWith("Session ID: ")) {
        return text.replace("Session ID: ", "");
      }
      // If text is "No session ID currently defined", return "default"
      if (text === "No session ID currently defined") {
        return "default";
      }
      return "default";
    }

    function updateAddressBar(session) {
      const url = new URL(window.location);
      if (!session || session === "default") {
        url.searchParams.delete("session");
      } else {
        url.searchParams.set("session", session);
      }
      window.history.replaceState(null, "", url);
    }

    function updateButtonsLayout() {
      const onlyMiddle = optionsBtn.classList.contains("hidden") && resetBtn.classList.contains("hidden") && chartBtn.classList.contains("hidden");
      buttonsContainer.classList.toggle("single", onlyMiddle);
    }

    function updateButtonVisibility() {
      const session = getCurrentSession();
      const hasValidSession = session && session !== "default";
      const hasContent = totalSeconds > 0 || sessionState.red_teams > 0 || sessionState.green_teams > 0;
      
      console.log("🔘 Button visibility check:", {
        session,
        hasValidSession,
        totalSeconds,
        red_teams: sessionState.red_teams,
        green_teams: sessionState.green_teams,
        hasContent
      });
      
      if (!hasValidSession) {
        // No session or invalid session: only show pen (options) button
        console.log("🔘 Showing only pen button (no valid session)");
        optionsBtn.classList.remove("hidden");
        toggleBtn.classList.add("hidden");
        resetBtn.classList.add("hidden");
        chartBtn.classList.add("hidden");
      } else if (hasContent) {
        // Valid session with content: show all four buttons
        console.log("🔘 Showing all four buttons (valid session + content)");
        optionsBtn.classList.remove("hidden");
        toggleBtn.classList.remove("hidden");
        resetBtn.classList.remove("hidden");
        chartBtn.classList.remove("hidden");
      } else {
        // Valid session but no content: show only pen button
        console.log("🔘 Showing only pen button (valid session but no content)");
        optionsBtn.classList.remove("hidden");
        toggleBtn.classList.add("hidden");
        resetBtn.classList.add("hidden");
        chartBtn.classList.add("hidden");
      }
      
      updateButtonsLayout();
    }

    function formatTime(mins, secs) {
      const m = String(mins).padStart(2, '0');
      const s = String(secs).padStart(2, '0');
      return `${m}:${s}`;
    }

    function updateTimerDisplay() {
      const mins = Math.floor(totalSeconds / 60);
      const secs = totalSeconds % 60;
      timerDisplay.textContent = formatTime(mins, secs);
    }

    function setToggleButtonToStart() {
      toggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 4v16l13 -8z" /></svg> Start`;
      toggleBtn.classList.remove("primary-active");
      toggleBtn.classList.add("primary-idle");
      toggleBtn.disabled = false;
    }

    // ─── Core functions ───
    function createDots(count, color, size) {
      console.log(`🎯 Creating ${count} ${color} dots with size: ${size}`);
      
      const container = color === "red" ? document.getElementById("left-dots") : document.getElementById("right-dots");
      container.innerHTML = "";
      
      const numCount = parseInt(count, 10) || 0;
      if (numCount <= 0) return;

      const dotSizeMap = { S: 16, M: 30, L: 50, XL: 80 };
      const px = `${dotSizeMap[size] || 16}px`;
      
      const useDatadog = sessionState.dot_style === "datadog_bits";
      for (let i = 0; i < numCount; i++) {
        if (useDatadog) {
          const img = document.createElement("img");
          img.className = "dot-img";
          img.src = color === "red" ? "/static/datadog_red.gif" : "/static/datadog_green.gif";
          img.style.width = px;
          img.style.height = px;
          container.appendChild(img);
        } else {
          const dot = document.createElement("div");
          dot.classList.add("dot", color);
          dot.style.setProperty("width", px, "important");
          dot.style.setProperty("height", px, "important");
          container.appendChild(dot);
        }
      }
      
      console.log(`🎯 Created ${numCount} ${color} dots with size ${px} (${useDatadog ? 'Datadog' : 'circle'})`);
      updatePingingState();
    }

    // ─── Dynamic Contrast Detection ───
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }

    function calculateBrightness(r, g, b) {
      // Using luminance formula: 0.299*R + 0.587*G + 0.114*B
      return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    }

    function analyzeImageBrightness(imageSrc) {
      return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = function() {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = img.width;
          canvas.height = img.height;
          
          // Draw image to canvas
          ctx.drawImage(img, 0, 0);
          
          // Sample pixels from the image
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          
          let totalBrightness = 0;
          let sampleCount = 0;
          
          // Sample every 10th pixel for performance
          for (let i = 0; i < data.length; i += 40) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            totalBrightness += calculateBrightness(r, g, b);
            sampleCount++;
          }
          
          const averageBrightness = totalBrightness / sampleCount;
          resolve(averageBrightness > 0.6);
        };
        
        img.onerror = function() {
          // Fallback to heuristic analysis
          const lightImageKeywords = ['white', 'light', 'bright', 'cannes', 'timer-bg'];
          const imageName = sessionState.background_image.toLowerCase();
          resolve(lightImageKeywords.some(keyword => imageName.includes(keyword)));
        };
        
        img.src = imageSrc;
      });
    }

    async function isBackgroundLight() {
      // Check if we have a background image
      if (sessionState.background_image) {
        // Always treat these images as 'dark' (use white text)
        const alwaysDarkImages = [
          'BH7K8K_cannes_new_1751654344.png',
          'cannes_new.png',
          'timer-bg.png'
        ];
        if (alwaysDarkImages.includes(sessionState.background_image)) {
          return false; // Always use white text for these images
        }
        try {
          const imageSrc = `/static/${sessionState.background_image}`;
          return await analyzeImageBrightness(imageSrc);
        } catch (error) {
          // Fallback to heuristic analysis
          const lightImageKeywords = ['white', 'light', 'bright'];
          const imageName = sessionState.background_image.toLowerCase();
          return lightImageKeywords.some(keyword => imageName.includes(keyword));
        }
      }
      // For solid colors, calculate brightness
      if (sessionState.background_color) {
        const rgb = hexToRgb(sessionState.background_color);
        if (rgb) {
          const brightness = calculateBrightness(rgb.r, rgb.g, rgb.b);
          return brightness > 0.6; // Threshold for "light" background
        }
      }
      return false; // Default to dark
    }

    async function applyDynamicContrast() {
      let isLight;
      let forceMode = null;
      // Check contrast mode setting
      switch (sessionState.contrast_mode) {
        case "light":
          forceMode = "light"; // Force light text (white)
          break;
        case "dark":
          forceMode = "dark"; // Force dark text (black)
          break;
        case "auto":
        default:
          isLight = await isBackgroundLight();
          break;
      }
      // Update CSS custom properties and classes
      if (forceMode === "light") {
        document.documentElement.style.setProperty('--text-contrast', 'rgba(255, 255, 255, 0.9)');
        document.documentElement.style.setProperty('--button-bg-contrast', 'rgba(255, 255, 255, 0.1)');
      } else if (forceMode === "dark") {
        document.documentElement.style.setProperty('--text-contrast', 'rgba(0, 0, 0, 0.9)');
        document.documentElement.style.setProperty('--button-bg-contrast', 'rgba(0, 0, 0, 0.1)');
      } else if (typeof isLight !== 'undefined') {
        if (isLight) {
          document.documentElement.style.setProperty('--text-contrast', 'rgba(0, 0, 0, 0.9)');
          document.documentElement.style.setProperty('--button-bg-contrast', 'rgba(0, 0, 0, 0.1)');
        } else {
          document.documentElement.style.setProperty('--text-contrast', 'rgba(255, 255, 255, 0.9)');
          document.documentElement.style.setProperty('--button-bg-contrast', 'rgba(255, 255, 255, 0.1)');
        }
      }
      // Determine which class to apply
      let contrastClass = '';
      if (forceMode === "light") contrastClass = 'contrast-dark';
      else if (forceMode === "dark") contrastClass = 'contrast-light';
      else contrastClass = isLight ? 'contrast-light' : 'contrast-dark';
      // Apply contrast classes to elements
      const elements = document.querySelectorAll('.buttons button, .round, #config-button');
      elements.forEach(el => {
        el.classList.remove('button-contrast-light', 'button-contrast-dark');
        el.classList.add(contrastClass === 'contrast-light' ? 'button-contrast-light' : 'button-contrast-dark');
      });
      // Timer display
      timerDisplay.classList.remove('timer-contrast-light', 'timer-contrast-dark');
      if (sessionState.font_color === "#000000" && !sessionState.custom_font_color_set) {
        timerDisplay.classList.add(contrastClass === 'contrast-light' ? 'timer-contrast-light' : 'timer-contrast-dark');
      }
      // QR section
      const qrSection = document.querySelector(".qr-section");
      qrSection.classList.remove('contrast-light', 'contrast-dark');
      qrSection.classList.add(contrastClass);
      // Session indicator
      const sessionIndicator = document.getElementById("session-indicator");
      sessionIndicator.classList.remove('contrast-light', 'contrast-dark');
      sessionIndicator.classList.add(contrastClass);
      // QR label
      const qrLabel = document.querySelector(".qr-label");
      qrLabel.classList.remove('contrast-light', 'contrast-dark');
      qrLabel.classList.add(contrastClass);
      console.log(`🎨 Applied contrast mode: ${sessionState.contrast_mode} (${contrastClass})`);
    }

    function applyAppearance() {
      // Background
      if (sessionState.background_image) {
        // Failsafe: check if image exists
        const img = new window.Image();
        img.onload = function() {
          document.body.style.backgroundImage = `url("/static/${sessionState.background_image}")`;
          document.body.style.backgroundSize = "cover";
          document.body.style.backgroundRepeat = "no-repeat";
          document.body.style.backgroundPosition = "center";
          document.body.style.backgroundColor = "";
          // Apply dynamic contrast after background is set
          setTimeout(applyDynamicContrast, 100);
        };
        img.onerror = function() {
          document.body.style.backgroundImage = "none";
          document.body.style.backgroundColor = sessionState.background_color;
          // Apply dynamic contrast after background is set
          setTimeout(applyDynamicContrast, 100);
        };
        img.src = `/static/${sessionState.background_image}`;
      } else {
        document.body.style.backgroundImage = "none";
        document.body.style.backgroundColor = sessionState.background_color;
        // Apply dynamic contrast after background is set
        setTimeout(applyDynamicContrast, 100);
      }

      // Font
      document.body.style.fontFamily = `"${sessionState.font_family}", sans-serif`;
      
      // Timer display color - apply gradient only for default state, solid color for custom colors
      if (sessionState.font_color === "#000000" && !sessionState.custom_font_color_set) {
        // For default black, use the gradient effect
        timerDisplay.classList.add("gradient-text");
        timerDisplay.style.color = "";
      } else {
        // For any custom color (including black), use the solid color
        timerDisplay.classList.remove("gradient-text");
        timerDisplay.style.color = sessionState.font_color;
      }
      
      // Button colors
      document.documentElement.style.setProperty('--btn-primary', sessionState.font_color);
      document.documentElement.style.setProperty('--btn-secondary', sessionState.font_color + '99');
    }

    function applyTimer() {
      const minutes = parseInt(sessionState.minutes, 10) || 0;
      const seconds = parseInt(sessionState.seconds, 10) || 0;
      totalSeconds = minutes * 60 + seconds;
      updateTimerDisplay();
      
      // Update button visibility based on new logic
      updateButtonVisibility();
    }

    function applySettings(data) {
      console.log("🔧 Applying settings:", data);
      
      // Store current dot state before applying new settings
      const currentRedDots = document.querySelectorAll("#left-dots .dot.red, #left-dots img.dot-img").length;
      const currentGreenDots = document.querySelectorAll("#right-dots .dot.green, #right-dots img.dot-img").length;
      const wasTimerRunning = intervalId !== null;
      
      // Convert string values to numbers and update session state
      const processedData = {
        ...data,
        minutes: parseInt(data.minutes, 10) || 0,
        seconds: parseInt(data.seconds, 10) || 0,
        red_teams: parseInt(data.red_teams || data.teams, 10) || 0,
        green_teams: parseInt(data.green_teams, 10) || 0,
        dot_size: data.dot_size || "S",
        dot_style: data.dot_style || "datadog_bits",
        contrast_mode: data.contrast_mode || "auto",
        custom_font_color_set: true
      };
      
      console.log("🔧 Processed data:", processedData);
      Object.assign(sessionState, processedData);
      
      // Migrate old "datadog" to "datadog_bits" for backward compatibility
      if (sessionState.dot_style === "datadog") {
        sessionState.dot_style = "datadog_bits";
        console.log("🔄 Migrated dot_style from 'datadog' to 'datadog_bits' for backward compatibility");
      }
      
      console.log("🔧 Session state after update:", sessionState);
      
      // Apply changes
      applyAppearance();
      applyTimer();
      
      // Create dots based on new settings values
      createDots(sessionState.red_teams, "red", sessionState.dot_size);
      createDots(sessionState.green_teams, "green", sessionState.dot_size);
      
      // Update lastSeenCount to match current green dots
      lastSeenCount = sessionState.green_teams;
      
      // Set button state correctly based on timer state
      if (wasTimerRunning && totalSeconds > 0) {
        // Timer was running, keep it running and show Stop button
        toggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="currentColor"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.5 7.5a3 3 0 0 1 3-3h9a3 3 0 0 1 3 3v9a3 3 0 0 1-3 3h-9a3 3 0 0 1-3-3v-9Z"/></svg> Stop`;
        toggleBtn.classList.remove("primary-idle");
        toggleBtn.classList.add("primary-active");
      } else {
        setToggleButtonToStart();
      }
      
      // Update session indicator
      if (data.session_id && data.session_id !== "" && data.session_id !== null) {
        const sessionIndicator = document.getElementById("session-indicator");
        sessionIndicator.textContent = `Session ID: ${data.session_id}`;
        sessionStorage.setItem("session", data.session_id);
        updateAddressBar(data.session_id);
        
        const qrImg = document.querySelector(".qr-section img");
        if (qrImg) qrImg.src = `/qr-image?session=${encodeURIComponent(data.session_id)}`;
      } else {
        // Clear session when session_id is empty, null, or undefined
        const sessionIndicator = document.getElementById("session-indicator");
        sessionIndicator.textContent = "No session ID currently defined";
        sessionStorage.removeItem("session");
        updateAddressBar("");
        
        const qrImg = document.querySelector(".qr-section img");
        if (qrImg) qrImg.src = "/qr-image";
      }
      
      console.log("🔧 Settings applied - Dot state: red=" + sessionState.red_teams + ", green=" + sessionState.green_teams);
      const currentSession = getCurrentSession();
      fetch(`/reset?session=${encodeURIComponent(currentSession)}`, { method: "POST" });
    }

    async function saveSessionState() {
      try {
        const session = getCurrentSession();
        console.log(`🔧 CLIENT: Saving session "${session}" with state:`, sessionState);
        const response = await fetch(`/api/session-state?session=${encodeURIComponent(session)}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(sessionState)
        });
        console.log(`🔧 CLIENT: Save response status: ${response.status}`);
        if (!response.ok) {
          console.error(`🔧 CLIENT: Save failed with status ${response.status}`);
        } else {
          console.log(`🔧 CLIENT: Session "${session}" saved successfully`);
        }
      } catch (err) {
        console.warn("Failed to save session state:", err);
      }
    }

    async function loadSessionState() {
      try {
        // Get session from URL parameter or sessionStorage directly
        const urlSession = new URLSearchParams(window.location.search).get("session");
        const session = urlSession || sessionStorage.getItem("session") || "";
        
        // If no session (default mode), always load golden standard
        if (!session || session === "default") {
          const gsResp = await fetch('/api/golden-standard');
          if (gsResp.ok) {
            const gsData = await gsResp.json();
            Object.assign(sessionState, gsData);
            applyAppearance();
            applyTimer();
            createDots(sessionState.red_teams || 0, "red", sessionState.dot_size);
            createDots(sessionState.green_teams || 0, "green", sessionState.dot_size);
          }
        } else {
          // Load specific session data
          const resp = await fetch(`/api/session-state?session=${encodeURIComponent(session)}`);
          if (resp.ok) {
            const data = await resp.json();
            if (data && Object.keys(data).length > 0) {
              Object.assign(sessionState, data);
              
              // Migrate old "datadog" to "datadog_bits" for backward compatibility
              if (sessionState.dot_style === "datadog") {
                sessionState.dot_style = "datadog_bits";
                console.log("🔄 Migrated dot_style from 'datadog' to 'datadog_bits' for backward compatibility");
              }
              
              applyAppearance();
              applyTimer();
              createDots(sessionState.red_teams || sessionState.teams || 0, "red", sessionState.dot_size);
              createDots(sessionState.green_teams || 0, "green", sessionState.dot_size);
            } else {
              // Fallback to golden standard if session data is empty (invalid session)
              
              // Clear invalid session from storage and URL (like double reset does)
              sessionStorage.removeItem("session");
              updateAddressBar("");
              
              const gsResp = await fetch('/api/golden-standard');
              if (gsResp.ok) {
                const gsData = await gsResp.json();
                Object.assign(sessionState, gsData);
                applyAppearance();
                applyTimer();
                createDots(sessionState.red_teams || 0, "red", sessionState.dot_size);
                createDots(sessionState.green_teams || 0, "green", sessionState.dot_size);
              }
            }
          } else {
            // Fallback to golden standard if session doesn't exist or server error
            
            // Clear invalid session from storage and URL (like double reset does)
            sessionStorage.removeItem("session");
            updateAddressBar("");
            
            // Load golden standard
            const gsResp = await fetch('/api/golden-standard');
            if (gsResp.ok) {
              const gsData = await gsResp.json();
              Object.assign(sessionState, gsData);
              applyAppearance();
              applyTimer();
              createDots(sessionState.red_teams || 0, "red", sessionState.dot_size);
              createDots(sessionState.green_teams || 0, "green", sessionState.dot_size);
              
              // Update session indicator to show no session
              updateSessionIndicator();
            }
          }
        }
        
        // After loading session state, also fetch current scan count
        const pingResp = await fetch(`/ping?session=${encodeURIComponent(session)}`);
        if (pingResp.ok) {
          const count = parseInt(await pingResp.text(), 10);
          lastSeenCount = count;
          initialScanCountLoaded = true;
        }
      } catch (err) {
        console.warn("Could not load session state or scan count:", err);
      }
    }

    // ─── Event handlers ───
    window.addEventListener("message", async function (event) {
      if (event.data.type === "settings") {
        console.log("🟢 Received settings:", event.data);
        console.log("🟢 Dot size received:", event.data.dot_size);
        console.log("🟢 All fields:", {
          minutes: event.data.minutes,
          seconds: event.data.seconds,
          teams: event.data.teams,
          green_teams: event.data.green_teams,
          dot_size: event.data.dot_size,
          session_id: event.data.session_id
        });
        
        applySettings(event.data);
        await saveSessionState();
        console.log("✔️ Settings applied and saved");
        
        // Reset the reset state when new settings are applied
        resetState = "ready";

        // Update session indicator and storage
        if (!event.data.session_id || event.data.session_id === "default" || event.data.session_id === null) {
          sessionStorage.removeItem("session");
          updateAddressBar("");
          
          // Reload golden standard when clearing session
          try {
            const gsResp = await fetch('/api/golden-standard');
            if (gsResp.ok) {
              const gsData = await gsResp.json();
              Object.assign(sessionState, gsData);
              applyAppearance();
              applyTimer();
              createDots(sessionState.red_teams || 0, "red", sessionState.dot_size);
              createDots(sessionState.green_teams || 0, "green", sessionState.dot_size);
              updateButtonVisibility(); // Update buttons after golden standard reload
            }
          } catch (err) {
            console.warn("Could not reload golden standard:", err);
          }
        } else {
          sessionStorage.setItem("session", event.data.session_id);
          updateAddressBar(event.data.session_id);
        }
        
        // Always update session indicator after all changes
        updateSessionIndicator();
        
        // Critical: Update button visibility after all session changes are complete
        updateButtonVisibility();
      } else if (event.data.type === "json-changed-external") {
        console.log("🔄 Received external JSON change notification:", event.data);
        // Force reload session state from JSON
        lastKnownSessionState = null; // Reset to force reload
        loadSessionState();
      } else if (event.data.type === "reset-to-default") {
        console.log("🔄 Received reset-to-default message from:", event.origin);
        console.log("🔄 Message data:", event.data);
        
        // Clear session storage and URL
        sessionStorage.removeItem("session");
        console.log("🔄 Cleared sessionStorage");
        updateAddressBar("");
        console.log("🔄 Updated address bar");
        
        // Reload golden standard
        try {
          const gsResp = await fetch('/api/golden-standard');
          if (gsResp.ok) {
            const gsData = await gsResp.json();
            Object.assign(sessionState, gsData);
            applyAppearance();
            applyTimer();
            createDots(sessionState.red_teams || 0, "red", sessionState.dot_size);
            createDots(sessionState.green_teams || 0, "green", sessionState.dot_size);
            updateSessionIndicator();
            updateButtonVisibility(); // Update buttons after reset to default
            console.log("✔️ Reset to golden standard completed");
          }
        } catch (err) {
          console.warn("Could not reload golden standard for reset:", err);
        }
      }
    });

    // ─── Button handlers ───
    optionsBtn.onclick = openSettings;
    
    // Chart button handler - opens statistics modal
    chartBtn.onclick = openStatistics;

    toggleBtn.addEventListener("click", () => {
      if (toggleBtn.onclick === openSettings) {
        openSettings();
        return;
      }
      if (totalSeconds === 0 && sessionState.red_teams === 0 && sessionState.green_teams === 0) {
        openSettings();
        return;
      }

      if (!intervalId && totalSeconds > 0) {
        // Initialize session stats when timer starts
        const currentSession = getCurrentSession();
        fetch(`/reset?session=${encodeURIComponent(currentSession)}`, { method: "POST" });
        
        // Start timer
        intervalId = setInterval(() => {
          totalSeconds--;
          updateTimerDisplay();
          if (totalSeconds <= 0) {
            clearInterval(intervalId);
            intervalId = null;
            toggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 4v16l13 -8z" /></svg> Start`;
            toggleBtn.classList.remove("primary-active");
            toggleBtn.classList.add("primary-idle");
            toggleBtn.disabled = true;
            timerDisplay.textContent = "00:00";
            timerDisplay.classList.remove("gradient-text");
            timerDisplay.style.color = "red";
            timerDisplay.classList.add("flashing-red");
          }
        }, 1000);
        toggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="currentColor"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.5 7.5a3 3 0 0 1 3-3h9a3 3 0 0 1 3 3v9a3 3 0 0 1-3 3h-9a3 3 0 0 1-3-3v-9Z"/></svg> Stop`;
        toggleBtn.classList.remove("primary-idle");
        toggleBtn.classList.add("primary-active");
        updateButtonVisibility(); // Use new logic instead of always showing reset
        // Reset the reset state when timer starts
        resetState = "ready";
      } else {
        // Pause timer
        clearInterval(intervalId);
        intervalId = null;
        toggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 4v16l13 -8z" /></svg> Start`;
        toggleBtn.classList.remove("primary-active");
        toggleBtn.classList.add("primary-idle");
      }
    });

    // Track reset state for the improved workflow
    let resetState = "ready"; // "ready", "restored", "cleared"

    resetBtn.addEventListener("click", async () => {
      wasTimerRunning = intervalId !== null;
      clearInterval(intervalId);
      intervalId = null;
      lastSeenCount = 0;

      // Determine the originally set values from session
      const setSeconds = (parseInt(sessionState.minutes, 10) || 0) * 60 + (parseInt(sessionState.seconds, 10) || 0);
      const setRedTeams = sessionState.red_teams || 0;
      const setGreenTeams = sessionState.green_teams || 0;

      if (resetState === "ready") {
        // First click: Restore to session settings (timer and team counts)
        console.log("🔄 First reset: Restoring to session settings");
        totalSeconds = setSeconds;
        updateTimerDisplay();
        createDots(setRedTeams, "red", sessionState.dot_size);
        createDots(0, "green", sessionState.dot_size); // No green dots moved yet
        toggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 4v16l13 -8z" /></svg> Start`;
        toggleBtn.classList.remove("primary-active");
        toggleBtn.classList.add("primary-idle");
        toggleBtn.disabled = false;
        timerDisplay.classList.remove("flashing-red");
        // Restore proper font color after reset
        applyAppearance();
        // Update button visibility based on new logic
        updateButtonVisibility();
        resetState = "restored";
        
      } else if (resetState === "restored") {
        // Second click: Reset timer and teams to zero, clear session (back to no-session mode)
        console.log("🔄 Second reset: Clearing timer, teams, and session (back to no-session mode)");
        totalSeconds = 0;
        updateTimerDisplay();
        createDots(0, "red", sessionState.dot_size);
        createDots(0, "green", sessionState.dot_size);
        // Clear the team counts in sessionState so the button logic works correctly
        sessionState.red_teams = 0;
        sessionState.green_teams = 0;
        sessionState.minutes = 0;
        sessionState.seconds = 0;
        // Clear session storage and URL to go back to "no session" mode
        sessionStorage.removeItem("session");
        updateAddressBar("");
        updateSessionIndicator();
        toggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 4v16l13 -8z" /></svg> Start`;
        toggleBtn.classList.remove("primary-active");
        toggleBtn.classList.add("primary-idle");
        toggleBtn.disabled = false;
        timerDisplay.classList.remove("flashing-red");
        // Restore proper font color after reset
        applyAppearance();
        // Update button visibility based on new logic
        updateButtonVisibility();
        resetState = "cleared";
      }

      // Save the reset state to backend
      await saveSessionState();
      const currentSession = getCurrentSession();
      fetch(`/reset?session=${encodeURIComponent(currentSession)}`, { method: "POST" });
      updatePingingState(); // Ensure pinging state is updated after all changes
    });

    // Config button removed - edit-config functionality moved to Settings window

    // ─── Settings & QR functions ───
    function openSettings() {
      // Remove random session ID generation
      // let sess = sessionStorage.getItem("session");
      // if (!sess || sess === "default") {
      //   const newId = Math.random().toString(36).substr(2, 6).toUpperCase();
      //   sessionStorage.setItem("session", newId);
      // }
      // Center the settings window on the screen and make it taller
      const width = 500;
      const height = 650;
      const left = window.screenX + (window.outerWidth - width) / 2;
      const top = window.screenY + (window.outerHeight - height) / 2;

      const settingsWindow = window.open("/settings", "_blank", `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes`);
      const currentSession = getCurrentSession();
      
      // Track the opened settings window
      if (settingsWindow) {
        openedSettingsWindows.push(settingsWindow);
      }

      // Always send the current timer value (totalSeconds)
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;

      settingsWindow.addEventListener("load", () => {
        settingsWindow.postMessage({
          type: "position-settings-window",
          left,
          top,
          prefill_session_id: (currentSession && currentSession !== "default") ? currentSession : "",
          prefill_minutes: minutes,
          prefill_seconds: seconds,
          prefill_red_teams: sessionState.red_teams || sessionState.teams || 0,
          prefill_green_teams: sessionState.green_teams || 0,
          prefill_dot_size: sessionState.dot_size,
          prefill_background_color: sessionState.background_color,
          prefill_font_color: sessionState.font_color,
          prefill_font_family: sessionState.font_family,
          prefill_background_image: sessionState.background_image,
          prefill_dot_style: sessionState.dot_style, // Pass dot_style
          prefill_contrast_mode: sessionState.contrast_mode // Pass contrast_mode
        }, "*");
      });
    }

    function openStatistics() {
      // Center the statistics window on the screen
      const width = 700;
      const height = 650;
      const left = window.screenX + (window.outerWidth - width) / 2;
      const top = window.screenY + (window.outerHeight - height) / 2;

      const currentSession = getCurrentSession();
        const statisticsWindow = window.open(`/statistics-v2?session=${encodeURIComponent(currentSession)}`, "_blank", `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes`);

      statisticsWindow.addEventListener("load", () => {
        statisticsWindow.postMessage({
          type: "position-statistics-window",
          left,
          top,
          session_id: currentSession
        }, "*");
      });
    }

    function openQrPopup() {
      const qrImg = document.querySelector(".qr-section img");
      const rect = qrImg.getBoundingClientRect();
      const width = 500;
      const height = 600;
      const left = window.screenX + rect.left;
      const top = window.screenY + rect.bottom + 10;

      const qrWindow = window.open("/qr-popup", "_blank", `width=${width},height=${height},left=${left},top=${top},resizable=yes`);
      const currentSession = getCurrentSession();

      qrWindow.addEventListener("load", () => {
        qrWindow.postMessage({
          type: "position-qr-window",
          left,
          top,
          session_id: currentSession
        }, "*");
      });
    }

    // ─── Report green dot count for accurate statistics ───
    async function reportGreenDotCount() {
      try {
        const currentSession = getCurrentSession();
        const greenDotCount = document.querySelectorAll("#right-dots .dot.green, #right-dots img.dot-img").length;
        
        await fetch(`/report-green-dots?session=${encodeURIComponent(currentSession)}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            green_dots: greenDotCount
          })
        });
        
        console.log(`📊 Reported ${greenDotCount} green dots for session ${currentSession}`);
      } catch (error) {
        console.warn('Failed to report green dot count:', error);
      }
    }

    // ─── Dot flight animation ───
    function animateDotFlight(redDot) {
      if (window.matchMedia("(max-width: 600px)").matches) {
        if (sessionState.dot_style === "datadog_bits") {
          redDot.src = "/static/datadog_green.gif";
          document.getElementById("right-dots").appendChild(redDot);
        } else {
          redDot.classList.replace("red", "green");
          // Preserve the dot size when moving to mobile
          const currentWidth = redDot.style.width || "16px";
          const currentHeight = redDot.style.height || "16px";
          redDot.style.setProperty("width", currentWidth, "important");
          redDot.style.setProperty("height", currentHeight, "important");
          document.getElementById("right-dots").appendChild(redDot);
        }
        
        // Check if this was the last red dot
        const selector = sessionState.dot_style === "datadog_bits" ? "#left-dots img.dot-img" : "#left-dots .dot.red";
        if (document.querySelectorAll(selector).length === 0) {
          showFinishState();
        }
        return;
      }

      const startRect = redDot.getBoundingClientRect();
      const rightCol = document.getElementById("right-dots");
      const endRect = rightCol.getBoundingClientRect();

      let clone;
      if (sessionState.dot_style === "datadog_bits") {
        clone = redDot.cloneNode(false);
        clone.style.position = "fixed";
        clone.style.left = `${startRect.left}px`;
        clone.style.top = `${startRect.top}px`;
        clone.style.width = `${startRect.width}px`;
        clone.style.height = `${startRect.height}px`;
        clone.style.borderRadius = "50%";
        clone.style.zIndex = 9999;
        clone.style.willChange = "transform";
        document.body.appendChild(clone);
      } else {
        clone = redDot.cloneNode(false);
        clone.style.position = "fixed";
        clone.style.left = `${startRect.left}px`;
        clone.style.top = `${startRect.top}px`;
        clone.style.width = `${startRect.width}px`;
        clone.style.height = `${startRect.height}px`;
        clone.style.borderRadius = "50%";
        clone.style.backgroundColor = "red";
        clone.style.zIndex = 9999;
        clone.style.willChange = "transform, background-color";
        document.body.appendChild(clone);
      }

      redDot.remove();

      const upDistance = -(startRect.top - 40);
      const acrossDistance = (endRect.left + (endRect.width - startRect.width) / 2) - startRect.left;
      const downDistance = (endRect.bottom - startRect.height / 2) - 40;

      const tr = (dx, dy) => `translate(${dx}px, ${dy}px)`;

      clone.style.transform = tr(0, 0);
      requestAnimationFrame(() => {
        clone.style.transition = "transform 0.5s ease-out";
        requestAnimationFrame(() => {
          clone.style.transform = tr(0, upDistance);
        });
      });

      setTimeout(() => {
        clone.style.transition = "transform 0.8s ease-out";
        clone.style.transform = tr(acrossDistance, upDistance);
      }, 550);

      setTimeout(() => {
        clone.style.transition = "transform 0.5s ease-in, background-color 0.2s linear";
        clone.style.transform = tr(acrossDistance, upDistance + downDistance);
        if (sessionState.dot_style === "datadog_bits") {
          clone.src = "/static/datadog_green.gif";
        } else {
          clone.style.backgroundColor = "green";
        }
      }, 1400);

      setTimeout(() => {
        if (sessionState.dot_style === "datadog_bits") {
          const newImg = document.createElement("img");
          newImg.className = "dot-img";
          newImg.src = "/static/datadog_green.gif";
          newImg.style.width = clone.style.width;
          newImg.style.height = clone.style.height;
          rightCol.appendChild(newImg);
        } else {
          const newDot = document.createElement("div");
          newDot.classList.add("dot", "green");
          newDot.style.setProperty("width", clone.style.width, "important");
          newDot.style.setProperty("height", clone.style.height, "important");
          rightCol.appendChild(newDot);
        }
        clone.remove();
        
        // Check if this was the last red dot, but delay flag for animation finish
        const selector = sessionState.dot_style === "datadog_bits" ? "#left-dots img.dot-img" : "#left-dots .dot.red";
        if (document.querySelectorAll(selector).length === 0) {
          setTimeout(showFinishState, 100); // Delay flag for animation
        }
      }, 1950);
      updatePingingState();
    }

    function showFinishState() {
      clearInterval(intervalId);
      intervalId = null;
      timerDisplay.textContent = "🏁";
      timerDisplay.style.color = "green";
      timerDisplay.style.fontWeight = "bold";
      timerDisplay.classList.remove("flashing-red");
      setToggleButtonToStart(); // Always set to Start in finished state
      // Make Start button open settings
      toggleBtn.onclick = openSettings;
      resetBtn.disabled = false;
    }

    async function checkForNewScans() {
      try {
        if (!initialScanCountLoaded) return; // Don't animate until initial count is loaded
        const currentSession = getCurrentSession();
        const res = await fetch(`/ping?session=${encodeURIComponent(currentSession)}`);
        const count = parseInt(await res.text(), 10);
        if (count > lastSeenCount) {
          let redDot;
          if (sessionState.dot_style === "datadog_bits") {
            redDot = document.querySelector("#left-dots img.dot-img");
          } else {
            redDot = document.querySelector("#left-dots .dot.red");
          }
          if (redDot) {
            animateDotFlight(redDot);
            lastSeenCount = count;
            
            // Report green dot count after UI decides to animate (aligns with polling logic)
            setTimeout(() => {
              reportGreenDotCount();
            }, 2000); // After animation completes
          }
        }
        // Remove finish state logic from here
        // const remainingRedDots = document.querySelectorAll("#left-dots .dot.red").length;
        // if (remainingRedDots === 0 && lastSeenCount > 0) {
        //   ...
        // }
        // else { ... }
      } catch (err) {
        console.error("Error pinging for scans:", err);
      }
    }

    // ─── Initialize ───
    function updateSessionIndicator() {
      const session = sessionStorage.getItem("session") || "";
      const sessionIndicator = document.getElementById("session-indicator");
      if (session) {
        sessionIndicator.textContent = `Session ID: ${session}`;
      } else {
        sessionIndicator.textContent = "No session ID currently defined";
      }
    }

    let scanIntervalId = null;

    function shouldStartPinging() {
      // Returns true if there are any red dots displayed
      return document.querySelectorAll("#left-dots .dot.red, #left-dots img.dot-img[src*='datadog_red']").length > 0;
    }

    function startPingingIfNeeded() {
      if (scanIntervalId === null && shouldStartPinging()) {
        scanIntervalId = setInterval(checkForNewScans, 2000);
        // console.log("Started pinging for scans");
      }
    }

    function stopPinging() {
      if (scanIntervalId !== null) {
        clearInterval(scanIntervalId);
        scanIntervalId = null;
        // console.log("Stopped pinging for scans");
      }
    }

    function updatePingingState() {
      if (shouldStartPinging()) {
        startPingingIfNeeded();
      } else {
        stopPinging();
      }
    }

    // Centralized session management on page load
    window.addEventListener("DOMContentLoaded", async () => {
      // Determine session from URL or sessionStorage
      let session = "";
      const urlSess = new URLSearchParams(window.location.search).get("session");
      if (urlSess) {
        session = urlSess;
        sessionStorage.setItem("session", session);
      } else {
        // Clear any old session data when no session in URL
        sessionStorage.removeItem("session");
        session = "";
      }

      // Load session state
      await loadSessionState();

      // Update session indicator
      updateSessionIndicator();
      
      // Get the current session after loadSessionState (might have been cleared if invalid)
      const currentSession = getCurrentSession();
      updateAddressBar(currentSession === "default" ? "" : currentSession);

      // Initialize QR
      const qrImg = document.querySelector(".qr-section img");
      if (qrImg) {
        qrImg.src = currentSession && currentSession !== "default" ? `/qr-image?session=${encodeURIComponent(currentSession)}` : "/qr-image";
      }

      // Update button visibility based on session validity
      updateButtonVisibility();
      
      // Start JSON synchronization monitoring
      // startJsonSync(); // REMOVED
      updatePingingState();
    });

    // ─── JSON Synchronization ───
    let lastKnownSessionState = null;
    // let jsonSyncInterval = null; // REMOVED
    let openedSettingsWindows = [];
    
    // Function to check if JSON has changed externally
    // async function checkForJsonChanges() { // REMOVED
    //   try {
    //     const session = getCurrentSession();
    //     if (!session || session === "default") return; // Skip for default session
        
    //     const resp = await fetch(`/api/session-state?session=${encodeURIComponent(session)}`);
    //     if (resp.ok) {
    //       const currentJsonState = await resp.json();
          
    //       // Compare with last known state
    //       if (lastKnownSessionState && JSON.stringify(currentJsonState) !== JSON.stringify(lastKnownSessionState)) {
    //         console.log("🔄 JSON changed externally, reloading session state");
            
    //         // Reload session state
    //         Object.assign(sessionState, currentJsonState);
            
    //         // Migrate old "datadog" to "datadog_bits" for backward compatibility
    //         if (sessionState.dot_style === "datadog") {
    //           sessionState.dot_style = "datadog_bits";
    //           console.log("🔄 Migrated dot_style from 'datadog' to 'datadog_bits' for backward compatibility");
    //         }
            
    //         // Apply changes
    //         applyAppearance();
    //         applyTimer();
    //         createDots(sessionState.red_teams || sessionState.teams || 0, "red", sessionState.dot_size);
    //         createDots(sessionState.green_teams || 0, "green", sessionState.dot_size);
            
    //         // Notify settings window if open
    //         notifySettingsWindowOfChange();
            
    //         // Update last known state
    //         lastKnownSessionState = currentJsonState;
    //       } else if (!lastKnownSessionState) {
    //         // Initialize last known state
    //         lastKnownSessionState = currentJsonState;
    //       }
    //     }
    //   } catch (err) {
    //     console.warn("Could not check for JSON changes:", err);
    //   }
    // }
    
    // Function to notify settings window of changes
    function notifySettingsWindowOfChange() {
      // Notify all opened settings windows of the change
      try {
        openedSettingsWindows.forEach(settingsWindow => {
          if (settingsWindow && !settingsWindow.closed) {
            settingsWindow.postMessage({
              type: "json-changed",
              session: getCurrentSession(),
              sessionState: sessionState
            }, "*");
          }
        });
        // Clean up closed windows
        openedSettingsWindows = openedSettingsWindows.filter(w => w && !w.closed);
        console.log("🔄 JSON changed, notified settings windows");
      } catch (err) {
        console.warn("Could not notify settings window:", err);
      }
    }
    
    // Start JSON synchronization monitoring
    // function startJsonSync() { // REMOVED
    //   if (jsonSyncInterval) {
    //     clearInterval(jsonSyncInterval);
    //   }
    //   jsonSyncInterval = setInterval(checkForJsonChanges, 3000); // Check every 3 seconds
    // }
    
    // Stop JSON synchronization monitoring
    // function stopJsonSync() { // REMOVED
    //   if (jsonSyncInterval) {
    //     clearInterval(jsonSyncInterval);
    //     jsonSyncInterval = null;
    //   }
    // }
    
    // Enhanced saveSessionState to update lastKnownSessionState
    const originalSaveSessionState = saveSessionState;
    saveSessionState = async function() {
      await originalSaveSessionState();
      // Update last known state after saving
      lastKnownSessionState = { ...sessionState };
    };
  </script>
</body>
</html>